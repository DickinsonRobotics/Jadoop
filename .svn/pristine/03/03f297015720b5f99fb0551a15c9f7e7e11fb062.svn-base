// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// This file is part of Jadoop
// Copyright (c) 2016 Grant Braught. All rights reserved.
// 
// Jadoop is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
// 
// Jadoop is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with Jadoop.
// If not, see <http://www.gnu.org/licenses/>.
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

package jadoop;

import jadoop.util.TextArrayWritable;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import org.apache.hadoop.io.*;
import org.apache.hadoop.mapreduce.Mapper;

/**
 * A Hadoop Mapper implementation that executes a command line task on the
 * execution node. The exit value and optionally standard output and standard
 * error generated by the process can be captured by the Mapper.
 * 
 * @author Grant Braught
 * @author Xiang Wei
 * @author Dickinson College
 * @version Jun 19, 2015
 */
public class HadoopGridTaskRunner extends
		Mapper<Text, TextArrayWritable, Text, MapWritable> {

	private static long PROCSSESS_POLL_DELAY = 500; // 1/2 sec.

	/**
	 * The map function that executes the command line task and outputs the
	 * return code, standard output and standard error.
	 * 
	 * The value provided as the input to this method will be a key and an array
	 * of Text objects. The key matches the key provided when the HadoopGridTask
	 * was added to the HadoopGridJob. The entries in the array are as follows:
	 * <UL>
	 * <LI>[0] - capStdOut: [true or false] If true, then all output to standard
	 * output by the execution of the command should be captured and returned as
	 * discussed below. If false, then standard output is not captured. This
	 * will be the first element of the ArrayWritable.
	 * <LI>[1] - capStdErr: [true or false] If true, then all output to standard
	 * error by the execution of the command should be captured and returned as
	 * discussed below. If false, then standard error is not captured. This will
	 * be the second element in ArrayWritable.
	 * <LI>[2] - timeout: The amount of time (in ms) that the task has to
	 * execute. If the command does not complete before the timeout it is
	 * terminated.
	 * <LI>[3] - command: The command to be executed. Any arguments to the
	 * command will be contained in subsequent entries.
	 * <LI>[4]... - arguments to the command. These would be the individual
	 * command line arguments if typed in at the command prompt.
	 * </UL>
	 * 
	 * <p>
	 * For example: if standard output of an execution of the cal command for
	 * June 2015 were to be captured the array entries would be:
	 * <UL>
	 * <LI>[0] - true
	 * <LI>[1] - false
	 * <LI>[2] - 1000
	 * <LI>[3] - cal
	 * <LI>[4] - 6
	 * <LI>[5] - 2015
	 * </UL>
	 * 
	 * <p>
	 * Entries 0-2 are used as flags, the remaining entries are converted to an
	 * array of Strings and used as the argument in a call to
	 * Runtime.getRuntime().exec() to run the command.
	 * 
	 * <p>
	 * The key generated for the Mapper result will be the same key passed into
	 * the mapper. The results generated for the Mapper will be a MapWritable
	 * object with the following key/value pairs:
	 * <UL>
	 * <LI>EV,value : the value is a IntWritable containing the exit value
	 * generated by the process created by the call to the Runtime.exec method.
	 * <LI>TO,value : the value will be a BooleanWriteable indicating if the
	 * task timed out (true) or not (false).
	 * <LI>SO,value : the value is a Text containing the output written to
	 * standard output by the executed program.
	 * <LI>SE,value : the value is a Text containing the output written to
	 * standard error by the executed program
	 * </UL>
	 * 
	 * @param key
	 *            a key that identifies this task. This will match the key
	 *            provided in the HadoopGridTask object.
	 * @param value
	 *            the flags and command line as described above.
	 * @param context
	 *            a Hadoop Context object provided by the Hadoop system.
	 * 
	 * @throws InterruptedException
	 *             if there is a problem writing the task result to the context.
	 * @throws IOException
	 *             if there is a problem writing the task result to the context.
	 */
	public void map(Text key, TextArrayWritable value, Context context)
			throws IOException, InterruptedException {

		String[] mapVal = value.toStrings();

		boolean capStdOutput = Boolean.parseBoolean(mapVal[0]);
		boolean capStdErr = Boolean.parseBoolean(mapVal[1]);
		long timeout = Long.parseLong(mapVal[2]);

		// Build the command.
		String[] cmdInput = new String[mapVal.length - 3];
		for (int i = 3; i < mapVal.length; i++) {
			cmdInput[i - 3] = mapVal[i];
		}

		StringBuffer stdOutputStr = new StringBuffer();
		StringBuffer errOutputStr = new StringBuffer();
		byte exitValue = 0;
		boolean timedout = false;

		try {
			// Executes the command.
			Process p = Runtime.getRuntime().exec(cmdInput);

			long start = System.currentTimeMillis();
			long cur = System.currentTimeMillis();
			boolean done = false;
			while (!timedout && !done) {
				Thread.sleep(PROCSSESS_POLL_DELAY);

				/*
				 * Check if the process has finished. If it has, the exit value
				 * will come back, if not it throws an exception.
				 */
				try {
					exitValue = (byte) p.exitValue();
					done = true;
				} catch (IllegalThreadStateException e) {
					// process not done yet, keep going...
				}

				cur = System.currentTimeMillis();
				long elapsedTime = (cur - start);
				timedout = (elapsedTime >= timeout);

				// Keep long running tasks alive with hadoop.
				context.setStatus("Running for: " + elapsedTime + ".");
			}

			// Capture standard output generated by the command.
			if (capStdOutput) {
				BufferedReader stdOutputPrg = new BufferedReader(
						new InputStreamReader(p.getInputStream()));
				while (stdOutputPrg.ready()) {
					stdOutputStr.append(stdOutputPrg.readLine());
					stdOutputStr.append("\n");
				}
			}

			// Capture standard error generated by the command
			if (capStdErr) {
				BufferedReader stdErrPrg = new BufferedReader(
						new InputStreamReader(p.getErrorStream()));
				while (stdErrPrg.ready()) {
					errOutputStr.append(stdErrPrg.readLine());
					errOutputStr.append("\n");
				}
			}

			if (timedout) {
				p.destroy(); // kill the process.
				exitValue = -1;
			}
		} catch (Exception e) {
			/*
			 * If an exception occurs put the message and stack trace on the end
			 * of the standard error returned.
			 */
			errOutputStr.append("\n" + e.getMessage() + "\n"
					+ e.getStackTrace());
			exitValue = -1;
		}

		// Put the results into the context that is returned from this mapper.
		Text evKey = new Text("EV");
		Text toKey = new Text("TO");
		Text soKey = new Text("SO");
		Text seKey = new Text("SE");
		
		ByteWritable bwExitVal = new ByteWritable(exitValue);
		BooleanWritable bwTimeout = new BooleanWritable(timedout);
		Text tStdOutputStr = new Text(stdOutputStr.toString().trim());
		Text tErrOutputStr = new Text(errOutputStr.toString().trim());

		MapWritable mw = new MapWritable();
		mw.put(evKey, bwExitVal);
		mw.put(toKey, bwTimeout);
		mw.put(soKey, tStdOutputStr);
		mw.put(seKey, tErrOutputStr);

		context.write(key, mw);
	}
}
